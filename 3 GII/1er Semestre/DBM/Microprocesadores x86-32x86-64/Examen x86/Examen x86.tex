%%\documentclass[a4paper,12pt,oneside]{llncs}
\documentclass[12pt,letterpaper]{article}
\usepackage[right=2cm,left=3cm,top=2cm,bottom=2cm,headsep=0cm]{geometry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Juego de caracteres usado en el archivo fuente: UTF-8
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Juego de caracteres usado en la salida dvi
%% Otra posibilidad: \usepackage{t1enc}
\usepackage[T1]{fontenc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ajusta maergenes para a4
%\usepackage{a4wide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Uso fuente postscript times, para que los ps y pdf queden y pequeños...
\usepackage{times}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Posibilidad de hipertexto (especialmente en pdf)
%\usepackage{hyperref}
\usepackage[bookmarks = true, colorlinks=true, linkcolor = black, citecolor = black, menucolor = black, urlcolor = black]{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Graficos 
\usepackage{graphics,graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ciertos caracteres "raros"...
\usepackage{latexsym}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Matematicas aun más fuertes (american math dociety)
\usepackage{amsmath}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{multirow} % para las tablas
\usepackage[spanish,es-tabla]{babel}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fuentes matematicas lo mas compatibles posibles con postscript (times)
%% (Esto no funciona para todos los simbolos pero reduce mucho el tamaño del
%% pdf si hay muchas matamaticas....
%\usepackage{mathptm}

%%% VARIOS:
%\usepackage{slashbox}
\usepackage{verbatim}
\usepackage{array}
\usepackage{listings}
\usepackage{multirow}

%% MARCA DE AGUA
%% Este package de "draft copy" NO funciona con pdflatex
%%\usepackage{draftcopy}
%% Este package de "draft copy" SI funciona con pdflatex
%%%\usepackage{pdfdraftcopy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Indenteacion en español...
\usepackage[spanish]{babel}
\usepackage[svgnames,x11names,table]{xcolor}
\usepackage{listings}
% Para escribir código en C
% \begin{lstlisting}[language=C]
% #include <stdio.h>
% int main(int argc, char* argv[]) {
% puts("Hola mundo!");
% }
% \end{lstlisting}


\title{Diseño Basado en Microprocesadores\\Examen parcial diciembre 2017}
%\author{Jesús Rodríguez Heras\\Roberto Muras González\\Juan Pedro Rodríguez Gracia\\Gabriel Fernando Sánchez Reina}
\date{ }

\begin{document}
	
	\maketitle
		
	%%\listoftables
	%%\newpage
	
	%%\listoffigures
	%%\newpage
	
	%%%% REAL WORK BEGINS HERE:
	
	%%Configuracion del paquete listings
	\lstset{language=bash, numbers=left, numberstyle=\tiny, numbersep=10pt, firstnumber=1, stepnumber=1, basicstyle=\small\ttfamily, tabsize=1, extendedchars=true, inputencoding=latin1}

\textbf{Tiempo: 2 horas.}
\begin{enumerate}
	\item Describe las características generales de la memoria de los microprocesadores x86. (1 punto)\\
	\item Describe el formato de los direccionamientos de memoria indirectos por registro de 32 bits de los microprocesadores x86 y pon un ejemplo de cada una de las combinaciones posibles. (1 punto).\\
	\item Realiza un diagrama donde se muestren los registros de 64 bits de los microprocesadores x86-64 indicando los nombres de los registros de 64 bits así como el de los registros de 32, 16 y 8 bits a los que se puede acceder dentro de éstos. (1 punto).\\
	\item Describe los tipos de datos escalares y empaquetados y tanto enteros como de punto flotante que pueden manejarse en los registros XMM. Realiza un diagrama de cada uno de ellos. (1 punto).\\
	\item Escribe un fichero fuente en ensamblador para un microprocesador x86 en el que se defina una función que devuelva el resultado de evaluar la función $f(x)=ax+b$, siendo $x$, $a$ y $b$ datos de tipo \texttt{int}. El prototipo de la función es:
	\begin{lstlisting}[language=C]
		int fun(int a, int x, int b);
	\end{lstlisting}
	La función podrá enlazarse en el código generado por un compilador de C de \textbf{32 bits.} (2 puntos).\\
	\item Escribe un fichero fuente en ensamblador para un microprocesador x68-64 en el que se defina una función que busque en un array de datos de tipo \texttt{unsigned int} aquellos cuyos bits de 0 a 15 sean iguales a sus bits de 16 a 31 y los copie en otro array. Por ejemplo, un dato con el valor \texttt{0x1A3F1A3F} cumple la condición para ser copiado. El prototipo de la función es:
	\begin{lstlisting}[language=C]
		int copiar_0a15_igual_16a31(const unsigned int * ptr_origen,
		                                  unsigned int num_datos,
		                                  unsigned int * ptr_destino,
		                                  unsigned int * num_copiados);
	\end{lstlisting}
	donde:
	\begin{itemize}
		\item \textbf{\texttt{ptr\_origen}} apunta al array con los datos entre los que buscar.
		\item \textbf{\texttt{num\_datos}} indica el número de datos contenidos en el array apuntado por \texttt{ptr\_origen}.
		\item \textbf{\texttt{ptr\_destino}} apunta al array donde hay que copiar aquellos datos que tengan los bits 0 a 15 iguales a los bits 16 a 31.
		\item \textbf{\texttt{num\_copiados}} apunta a una variable de tipo \texttt{unsigned int} donde la función debe dejar almacenado el número de datos del array origen que ha copiado en el array destino.
	\end{itemize}
	La función retorna 1 si realizó su trabajo correctamente y 0 si alguno de los puntero s es nulo.\\
	La función podrá enlazarse con el código generado por un compilador de C para Linux de 64 bits. (2 puntos).\\
	
	\item Escribe un fichero fuente con una función en ensamblador para un microprocesador x86-64 que use instrucciones SSE para sumar dos vectores cuyas componentes son números en punto flotante de precisión simple. El prototipo de la función es:
	\begin{lstlisting}[language=C]
		int sumar_vectores(const float * vector_1,
		                   const float * vecto_2,
		                   unsigned int dimension,
		                   float * vector_suma);
	\end{lstlisting}
	donde:
	\begin{itemize}
		\item \textbf{\texttt{vector\_1}} es un puntero a la primera componente del primer vector a sumar. Las componentes del vector están almacenadas una a continuación de otra.
		\item \textbf{\texttt{vector\_2}} es un puntero a la primera componente del segundo vector a sumar. Las componentes del vector están almacenadas una ca continuación de la otra.
		\item \textbf{\texttt{dimension}} es la dimensión (número de elementos) de los vectores a sumar. \textbf{La dimensión de los vectores no es necesariamente múltiplo de 4.}
		\item \textbf{\texttt{vector\_suma}} es un puntero a la posición de memoria a partir de la cual debe quedar almacenado el vector resultado de la suma.
	\end{itemize}
	Los punteros deben estar alineados en direcciones múltiplos de 16.\\
	La función retorna 1 si puede realizar correctamente su trabajo y 0 si alguno de los puntero es nulo o no está alienado.\\
	Aprovecha la capacidad de las instrucciones SSE de operar en paralelo sobre varios datos aunque, si la dimensión de los vectores no es un múltiplo de 4, algunos elementos tendrán que ser sumados mediante instrucciones SSE escalares.\\
	La función podrá enlazarse con el código generado por un compilador de C para Linux de \textbf{64 bits.} (2 puntos).
\end{enumerate}


\end{document}